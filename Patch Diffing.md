# Patch Diffing


![reign-abarintos--cKXtsJWU-I-unsplash](Resources/images/reign-abarintos--cKXtsJWU-I-unsplash.jpg)[](https://unsplash.com/photos/-cKXtsJWU-I)

## About

>Binary code similarity approaches compare two or more pieces of binary code to identify their similarities and differences. The ability to compare binary code enables many real-world applications on scenarios where source code may not be available such as patch analysis, bug search, and malware detection and analysis. [[S- 2021 - Article - A Survey of Binary Code Similarity - IrfanUlHaq2019]]

---

v1
Binary diffing simply refers to the comparison of two binaries. Whether the binary is of a different architecture or a variant of OS new version, it can be useful to analyze the differences to determine specific compiler changes, reasons for abnormal or unexpected behavior, finding new features or direction for new code, or discover details of a recently patched vulnerability. Ignoring what remains the same and focusing on the differences help the truth of what lies behind an update. 

v2
Binary diffing simply refers to the comparison of two binaries. Whether the binary is of a different architecture, a variant of OS version, or just the latest update it can be useful to analyze the differences to determine things like:
- specific compiler changes
- abnormal or unexpected behavior
- finding new features or direction for new code
- details of a recently patched vulnerability

The "diffing" refers to the process of ignoring what remains the same and focusing on the differences.  

---

Patch diffing (a specific form of binary diffing) is a technique to identify changes across versions of binaries as related to security patches. A patch diff is compares a vulnerable version of a binary with a patched one. The intent is to highlight the changes, helping to discover *new*, *missing*, and *interesting* functionality across various versions of a binary.

Discovery of new, missing,  and interesting functions:
```mermaid

flowchart LR;
linkStyle default interpolate basis

funcA1234<--Match 85%-->funcB2348
funcA1235<--Match 100%-->funcB2347
funcA1236<--Match 100%-->funcB2345
funcA1237<--Match 100%-->funcB2349

subgraph Binary Version B - patched
	funcB2345	
	subgraph NewFunc
		funcB2346
	end
	funcB2347
	subgraph Interesting
		funcB2348		
	end
	funcB2349
end

subgraph Binary Version A - vulnerable

	funcA1234
	funcA1235
	funcA1236
	funcA1237
	subgraph Missing
		funcA1238
	end
end

```


### Ecosystem

 >Overall, the risk of post-patch vulnerability exploitation is inevitable for software which can be freely reverse-engineered, and is thus accepted as a natural part of the ecosystem. [](https://googleprojectzero.blogspot.com/2017/10/using-binary-diffing-to-discover.html)
 
 Patch diffing is a reality of the modern day update process. For vendors of closed source software, an interesting dichotomy exists between the release of updates to improve the security of software while simultaneously providing malicious attackers and security researchers a vector to vulnerable code. This same tension is present within the vulnerability disclosure debate. 
 
 > Patch diffing is an often overlooked part of the perpetual vulnerability disclosure debate, **as vulnerabilities become public knowledge as soon as a software update is released, not when they are announced in release notes**. Skilled researchers can quickly determine the vulnerability that was fixed by comparing changes in the codebase between old and new versions. If the vulnerability is not publicly disclosed before or at the same time that the patch is released, then this could mean that the researchers who undertake the patch diffing effort could have more information than the defenders deploying the patches.[](https://googleprojectzero.blogspot.com/2020/04/tfw-you-get-really-excited-you-patch.html)
 
 The debate as whether or not public disclosure of vulnerabilities is ethical, is a [hot topic](https://www.scu.edu/ethics/focus-areas/business-ethics/resources/the-vulnerability-disclosure-debate/). The argument is that public disclosure raises awareness of security issues, pressuring vendors to fix them.  The counter argument is that disclosure provides a shortcut for attackers. The entire [premise](https://googleprojectzero.blogspot.com/2020/01/policy-and-disclosure-2020-edition.html) of groups like Project Zero releasing vulnerabilities for the "greater good" is hotly contested.  Whether or not you agree, it seems that patch diffing is a form of vulnerability disclosure that is **always public**.

## Benefits

### Single Source of Truth

>The blog post included details about the exploit, **but only included partial details on the vulnerability**. My end goal was to do variant analysis on the vulnerability, but without full and accurate details about the vulnerability, I needed to do a root cause analysis first. **I tried to get my hands on the exploit sample, but I wasn't able to source a copy. Without the exploit, I had to use binary patch diffing** in order to complete root cause analysis. [Maddie Stone -P0](https://googleprojectzero.blogspot.com/2020/04/tfw-you-get-really-excited-you-patch.html)

Patch diffing can be a deep well of vulnerability information on its own.  Often,  without a CVE blog post or sample POC, it is the **only source of information** to determine what changes were made and deduce the original issue. The skill in patch diffing is separating the the signal from all the noise (followed by a dash of  skill in reverse engineering). 

### Vulnerability Discovery through Re-Discovery

>It's also interesting to see that the graphical subsystem had fewer changes detected in general, but more than the core kernel specifically in the syscall handlers. **Once we knew the candidates, we manually investigated each of them in detail, discovering two new vulnerabilities** in the win32k!NtGdiGetFontResourceInfoInternalW and win32k!NtGdiEngCreatePalette system services. [](https://googleprojectzero.blogspot.com/2017/10/using-binary-diffing-to-discover.html)

On your path to understanding the original issue, you might be surprised by what you find.  A CVE combined with the latest patch to fix it has just transported you to an area of troubled code.  Do bugs congregate? Where one bug was found, are there not others? 

###  Practice Makes Perfect
Patch diffing could be applied to a researchers training regimen to hone their skill and keep them sharp. Patch diffing gives you both a goal and reduce the scope of what you are looking for.  Not only can you see more clearly, along the way you gain experience in reverse engineering and clarity into what actual security issues are. As you begin to build out mental models for various vulnerability classes, the energy needed to find them them decreases. And you ability to see them through all the noise increases as well.

Now that you are convinced that you should be patch diffing, what are the chances of all these benefits coming to fruition?

## Feasibility

>Security patches are often made to applications, libraries, driver files, etc.
When a new version is released it can be difficult to locate what changes were made
>- Some are new features or general application changes
>- Some are security fixes Some changes are intentional to thwart reversing
>- Some vendors make it clear as to reasoning for the update to the binary
>- Binary diffing tools can help us locate the changes 
>
>[bruh? Do you even diff - RSAcon2016](https://www.slideshare.net/cisoplatform7/bruh-do-you-even-diffdiffing-microsoft-patches-to-find-vulnerabilities?from_action=save)

Security fixes are typically not the only changes included in an update of a binary.  In addition, there is nothing to say that more than one bug won't be fixed within a single update.  A single executable having 1000s of functions also includes other libraries / external dependencies, and most times your software component is made of several binaries, increasing the difficulty of detecting changes, or at least multiplying the number of patch diffing sessions required to detect changes across builds. Even if there was only one change, understanding how to reach that code within a binary can be a very difficult task.  

### Minimize the noise

To support your success, there are a couple of tips to keep in mind.

#### Diff the correct binaries

> But as I alluded to above, it turns out I analyzed and wrote a crash POC for not CVE-2019-1458, but actually CVE-2019-1433.  [Maddie Stone admitting user error -P0](https://googleprojectzero.blogspot.com/2020/04/tfw-you-get-really-excited-you-patch.html)

It is not easy, you can get it wrong. There is no promise of success in patch diffing. In this particular case the researcher used the wrong set of relevant patch files. Following the aforementioned path from CVE -> relevant patch file should keep you on the straight and narrow for the correct patch. 


#### Reduce the time delta

>>A file such as mshtml.dll is patched almost every month. If you diff a version of the file from several months earlier with a patch that just came out, the number of differences between the two files will make analysis very difficult.  GrayHatHacking 2015

This one is obvious. The less changes your have to look at, the less chance there will be for confusion of analysis on unrelated changes. 

#### Cut the chatter

> James Forshaw advised me to patch diff the Windows 7 win32k.sys files rather than the Windows 10 versions. He suggested this for a few reasons:

> 1.  The signal to noise ratio is going to be much higher for Windows 7 rather than Windows 10. This “noise” includes things like [Control Flow Guard](https://docs.microsoft.com/en-us/windows/win32/secbp/control-flow-guard), more inline instrumentation calls, and “weirder” compiler settings.
> 2.  On Windows 10, win32k is broken up into a few different files: win32k.sys, win32kfull.sys, win32kbase.sys, rather than a single monolithic file.
> 3.  Kaspersky’s blog post stated that not all Windows 10 builds were affected.

This argument as to why to take a look at the Windows 7 security updates vs the Windows 10, alluded to in in [Windows 10 vs Windows 7 Cumulative patches](Security%20Patches.md#Windows%2010%20vs%20Windows%207%20Cumulative%20patches), follows the same vein of reducing complexity and increasing the signal to noise ratio.  For whatever system you are analysing, consider the same patch being applied on a simpler version of the operating system. 


#### Symbols - Prescription Lenses for SRE Tools 

For many (all?) of the available SRE tools, symbols add necessary precision to the comparison.  For Ghidra, it allows for a much quicker analysis and I assume the same across the board.  

>>Luckily, Microsoft, as well as some other vendors, provide symbols. **These symbols are extremely useful because we can often correlate the information provided in the patch bulletin with obvious symbol names.** When we look at CVE-2014-0254, which is associated with the patched vulnerability, as linked from the Microsoft website, it reads, “The IPv6 implementation in Microsoft Windows 8, Windows Server 2012, and Windows RT does not properly validate packets, which allows remote attackers to cause a denial of service (system hang) via crafted ICMPv6 Router Advertisement packets, aka ‘TCP/IP Version 6 (IPv6) Denial of Service Vulnerability.’”_4_ For quite a few years, it has been known that by sending IPv6 route advertisements using a random MAC address and a random IPv6 route prefix, you can cause a denial of service against many different devices._5_ Because we know that the vulnerability has to do with IPv6 and that route advertisements using prefixes is involved, let’s take a look at the symbol names showing as changed after the diff.  GrayHatHacking2015  [[S- 2021 - Article - GrayHatHacking - One-Day Exploitation with Patch Diffing Regalado2015]]

In addition to aiding SRE tools, the function names often relate to the CVE description field and can help narrow down which type of functions to look at simply by the function name. 


## Tools

For closed source or proprietary software, updates are typically shipped as executables. Their is no source code to analyze or perform a textual diff on to gain insight into what changes have occurred. For this, we turn to software reverse engineering tools that take much of the heavy lifting out of discover differences across binaries that contain 10s of 1000s of functions.  These SRE tools help navigate complexity of these binaries modulating the important differences from all of the code and data noise that hasn't changed. 

There was a recent [systematic analysis of modern binary diffing tools](https://arxiv.org/abs/1909.11424) completed with over 61 tools considered. Each tool was compared and several information was provided on each. 

3 primary ways of doing detection.

- syntax
- semantics
- structure


Each tool performs this to a different degree. 

### Which Diffing Tool To Use?


___
#fixthis 
There are several, and for brevity here is a recent list from [2019](https://github.com/maddiestone/ConPresentations/blob/master/Jailbreak2019.WhatsUpWithWhatsApp.pdf): 

- IDA
	- DarunGrim 
	- BinDiff plugin
	- Diaphora 
- Radare2 (radiff2)
- BinDiff
- Ghidra
	- Version Tracking Tool
	- BinExport
Ghidra version 9.1.2 is software reverse engineering (SRE) suite.
BinExport is the exporter component of BinDiff.
BinDiff version 6 is a comparison tool for binary files, that assists vulnerability researchers and engineers to quickly find differences and similarities in disassembled code.



| SRE Tool | Plugin | 
| --- | --- | 
| Ghidra | - Version Tracking tool | 
| IDA | 

___

### Batteries not included 

> -   No binary diffing tool out of the box will highlight \*which\* changes you’re likely to care about. That will still take learning the tools to optimize their findings and doing some RE of your own.
> -   Using a variety of different RE techniques can help you get to the answer faster
> [Jailbreak2019.WhatsUpWithWhatsApp.pdf](https://github.com/maddiestone/ConPresentations/blob/master/Jailbreak2019.WhatsUpWithWhatsApp.pdf)


No binary diffing tool will highlight the differences out of the box. There are too many variables in the equation.  Each tool has a separate workflow that will need to be tried, tested, and evolved.  The skill of reverse engineering will need to be added to the analysis to get the value required for understanding the underlying vulnerability. 


## Conclusion

Patch Diffing is not a panacea, a silver bullet, or trivial. It requires skilled reverse engineering pull out the differences signal from the noise of semantically unchanged functions. It can be a source of truth.  Did the change actually meet its mark? Did a security patch actually cure the [root cause](Root%20Cause%20Analysis.md)?

To answer these questions, this course will provide a walk through with a single tool and a few scripts you can use in the  [Ghidra Version Tracking](Ghidra%20Version%20Tracking.md) (aka Ghidra Patch Diffing) Tool section. 

Our path for the course is to attempt to analyze the differences across the previously identified Windows Print Spooler CVEs (2048,1337,17001). We will look at each diff individually using the lens of patch diffing as an attempt to get some clarity as to why it took so many attempts to get it right.

```mermaid
gantt

    title Patch diffing sessions comparing N-1,1048,1337,17001
    dateFormat  YYYY-MM-DD
	axisFormat %Y-%m
	
	section Relevant CVEs
	N-1 :a1, 2020-04-14, 2020-05-11 
    CVE-2020-1048 :a2, 2020-05-12, 2020-06-08
	CVE-2020-1337 :a3, 2020-08-11, 2020-09-07
	CVE-2020-17001 :a4, 2020-11-10, 2020-12-07
	
    section Patch Diffing Sessions
    Session1  :l1, 2020-04-14, 2020-06-08 
    Session2 :l2, 2020-06-08, 2020-09-07
	Session3 :l3, 2020-09-07, 2020-12-07
	


```

