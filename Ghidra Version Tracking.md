# Ghidra Version Tracking

Patch Diffing with Ghidra can be performed by it's **[Version Tracking Tool](https://ghidra.re/courses/GhidraClass/Intermediate/VersionTracking_withNotes.html#VersionTracking.html)**.  Not to be confused with it's [Program Difference Tool](https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/ProgramDiff/src/main/help/help/topics/Diff/Diff.htm)(which identifies changes in two applications for *porting changes* (aka binary patching) rather than *identifying* them for comparison.)

> Version Tracking refers to the process used by reverse engineers to identify matching code or data between different software binaries. One common use case is to version track two different versions of the same binary.  [[S- 2021 - Article - Version Tracking Ghidra - ghidra2018]]

The Version Tracking tool in Ghidra was built with two primary purposes:
- Port previous reverse engineering work to new binary (ie. bring over comments, labels, and other metadata considered *Ghidra Markup*)
- Determine whether or not code in the old binary exists in the new, and vice versa

Of the two purposes, patch diffing is concerned with the latter.  

## The Process

>This is the ultimate purpose of version tracking, to retain any progress that has already been made in understanding the code and be able to proceed despite any changes to the original binary. [[S- 2021 - Article - Version Tracking Ghidra - ghidra2018]]

For patch diffing, the ultimate purpose is to detect both changes and similarities between two binaries.  This ability will highlight changes, additions, and deletions. 


### High Level 
The version tracker tool provides a workflow to compare the code and data two different binaries by establishing a *session*, loading and auto-analyzing the binaries (after passing *precondition* checks), creating and identifying code and data *associations* using *correlators*, and eventually creating *matches* by assigning a score to the associations. 

Version Tracking Mini-glossary:
- **session** -  records the history and state of the version tracking session.  The order that correlators are run can affect the match results.
- **association** - a pairing of information between the two compared binaries 
	- information being metadata associated with the correlator algorithm, memory address, and type of item being associated (data or function)
- **correlator** - an algorithm used to score specific associations based on code, program flow, or any observable aspect of comparison
- **match** - an association that has been assigned a score
- **preconditions** - list of sanity check items the indicate that a binary has been sufficiently analyzed. This promotes the most accurate operation of the matching algorithms.

Leveraging the matches created by the workflow, trusting that `funcA1234` from Binary Version A is the same as `funcB5678` from Binary Version B, the number of functions to manually analyzes is greatly reduced. As the correlators begin to reduce the number of functions to analyze, the differences begin to emerge and an analyst can quickly begin to discover important changes to the binary.


## Version Tracker Workflow 

```mermaid

graph TD;

A[Create Session] ---> B[Load Binary Version A];
A ---> C[Load Binary Version B];
B --> D[Pass Preconditions];
C --> D; 
D --> E[Auto Analyze A/B];
E --> F[Choose / Run Correlators];
F --> G[Generate Associations];
G --> H[Evaluate Matches];
H --> I[Accept Matching Functions];
I --> J[Discover Enough Differences];
J -- Yes --> K[End];
J -- No --> F;


```

### Analyst View

The workflow is performed  done within the Version Tracker Tool GUI which is modeled as.

```mermaid

flowchart TD

A[Version Tracker View]<-->B[Source Binary Code Browser]
A<-->C[Destination Binary Code Browser]


```


##### Version Tracker View

![version_tracker_analysy_view](Resources/images/version_tracker_analysy_view.PNG)

This is the main patch diff analysis portal. In the upper pane, after you have selected which correlations to run, you view the results of all the created matches.  The matches will include important details such as the score (the % of similarity for the match) and the correlator or algorithm used to create the match. 

![version_matching_table](Resources/images/version_matching_table.png)

In the lower pane, you can select unmatched functions from the source and destination binary for direct comparison (both assembly and decompilations views are provided).

##### Code Browser (Source and Destination)

The standard Ghidra Code Browser is opened up for each of the separate binaries. As you select various functions within the Version Tracker view, the functions are auto link and opened in the corresponding Code Browser Tool.

### Setup and Prep (Step 1)

Collect the binaries that you want to compare.  This can be a single binary, or a collection of binaries across patches. Ideally, put them all in the same place. See [File Collection suggested](Environment%20Setup%20and%20Tooling.md#File%20Collection%20suggested).

Create a New Project in Ghidra.  Batch import them all into the same project. 

![load_files_vt](Resources/images/load_files_vt.PNG)

From there start a new Version Tracking Session via the *Version Tracking Wizard*. Each session is currently limited to two binaries.

![load_files_vt_plain](Resources/images/load_files_vt_plain.PNG)

If there is more than one version of the binary, multiple sessions will have to be performed to see differences related to each.

```mermaid

graph LR;

BinaryV1-- Session -->BinaryV2
BinaryV2-- Session2 -->BinaryV3
BinaryV3-- Session3 -->BinaryV4


```

That being said, there is nothing preventing the analysis. It depends on your goals and how often a binary changes over time. 

```mermaid

graph LR;

BinaryV1-- Session -->BinaryV4

```

### Auto-analysis (Step 2)

This step in the workflow simply loads both binaries into Ghidra's standard code browser and applies the auto-analysis standard procedure to the binaries.  As for any reverse engineering, [symbols](https://docs.microsoft.com/en-us/windows/win32/dxtecharts/debugging-with-symbols) here are helpful but not entirely necessary.   

### Run Correlators  (Step 3)

> **correlator** - an algorithm used to score specific associations based on code, program flow, or any observable aspect of comparison

As mentioned, correlators are algorithms or methods that take various inputs (basic blocks, data, functions) and create an association between two binaries and score them based on some heuristic. 

![ghidra_correlators_list](Resources/images/ghidra_correlators_list.PNG)

Generally, for binary comparison tools, there are 3 ways to determine whether or a function or input is the same in each binary[](https://arxiv.org/abs/1909.11424).

- **Syntax** - compare representation of actual bytes or sequence of instructions
    - Pros - Easy to compute, just hash the two binaries
    - Cons - Not generally realistic. Compiling the same source twice with the same compiler will generate a different hash, as this neive approach doesn't consider the time based metadata put into a binary by the compiler. 
- **Semantics** - compare the meaning is equivalent or provide the same functionality, or has similar effects
    - Pros - Less susceptible to metadata or simple compiler changes.
    - Cons - To prove two functions are semantically equivalent basically boils down to the [halting problem](https://en.wikipedia.org/wiki/Halting_problem). 
- **Structure** - a blend of semantic and syntax. Analyzes graph representations of binaries ( control flow, callgraphs, etc. ) and computes similarity on these generated structures
    - Pros - More general. A control flow is a type of semantic, and easier to compute. 

The list of correlators within Ghidra seem to primarily be a combination of syntax and structure correlators. 

#### Correlator Application Order
>In general, users should first run correlators that will find obvious matches and allow for automated matching and markup of a good portion of the destination program.

Ghidra suggests intuitively to start with the obvious correlators to find exact matches (syntax) as exact byte correlators have a high degree of accuracy.  These correlators will run to find functions and data that match exactly, then create matches by scoring the discovered associations. Some of the correlators will **automatically accept the matches**, reducing the workload for the analyst. This intuition has been added with a *Automatic Version Tracking* action. 

>The Automatic Version Tracking  action uses various correlators in a predetermined order to automatically create matches, accept the most likely matches, and apply markup all with one button press. The following correlators are run in this order:
> - Exact Symbol Name Correlator
> - Exact Data Correlator
> - Exact Function Bytes Correlator
> - Exact Function Instructions Correlator
> - Exact Function Mnemonics Correlator
> - Duplicate Function Instructions Correlator
> - Combined > - Function and Data Reference Correlator  

For patch diffing, this is the preferred method. Again, the idea is to boost the signal (differences,additions,deletions) by getting rid of the noise (functions that haven't changed). 

Further details about correlators can be found with the [Ghidra Correlator Documentation](somewhere) and there have even been some [custom ones](https://github.com/threatrack/ghidra-patchdiff-correlator) created to overcome some of the pitfalls of the built-in correlators. 

#findaplaceforthisinfo The cost however is *accuracy* in and *time*.  For example a 950KB Windows binary took about 20 mins to run through all the suggested correlators, vs about half the time with symbols loaded. This is because symbols provide Ghidra with some quick matches allowing subsequent runs of the correlators to run on the already matched functions (a 1 to 1 relationship vs a 1 to N). 

#### Boosting The Signal

>This uses Ghidra’s Version Tracking to diff a libpng update in order to extract the patch changes from it. While it works, it only works because the diffed library had symbols. **Ghidra is lacking a correlator to match functions that are only similar but include changes.** Ghidra is only good matching near identical functions, i.e., functions that did not change with the update.  [[S- 2021 - Blog - Patch Diffing with Ghidra - mich2019]]

Unfortunately, none of Ghidra's default correlators provide a score other than 100%. You are either a match or you aren't (based on each correlators criteria.)  

> Thus, I currently wouldn’t recommend Ghidra for patch diffing.
> **Update 1:** Now that there is [PatchDiffCorrelator](https://github.com/threatrack/ghidra-patchdiff-correlator) I fully recommend Ghidra for patch diffing! [[S- 2021 - Blog - Patch Diffing with Ghidra - mich2019]]

Luckily, a new plugin was created that helps solve this. Once you find the matches, you can run the PatchDiffCorrelator on the matches (to save you from running it on all functions and never completing that task). The new correlator is able to produce matches with a similarity score below 1.0, which is necessary for identifying functions that have the same symbol name, but are actually different.

The plugin provides three new *Bulk Correlator* options listed in increasing likelihood of generating a match or decreasing level of similarity required for matching:
- **Bulk Instructions Match** - Tokenize all *instuctions* within a function and place them in a unordered list.  (`pop ebp, ret, mov EBP,ESP, etc.`)
- **Bulk Mnemonics Match** - Tokenize all *instuctions mneumonics* (more coarse match) and place them in an unordered list (`pop,ret,mov, etc`)
- **Bulk Basic Block Mnemonics Match** - Tokenize all Mnemonics across basic blocks (a code sequence with no branches and only one entry and exit point) through the function.  These are placed into a list of all basic blocks of the function, sorted, and hashed.  These lists are then compared across the two functions.  This Bulk correlator has the most chance of matching a function


### Evaluating Matches (Step 4)

>Ultimately, the analyst has to inspect the actual code to make a determination about which associations represents a valid match.
>[[S- 2021 - Article - Version Tracking Ghidra - ghidra2018]]

Even though Ghidra automates quite a bit with *Automatic Version Tracking* and provides many built-in correlators, in the end the analyst has to do some work to identify whether or not specific functions match. 

#### Evaluation

The process of evaluation is best summed up in the latter half of the workflow diagram.

```mermaid

graph TD;

F[Choose / Run Correlators] --> G[Generate Associations];
G --> H[Evaluate Matches];
H --> I[Accept Matching Functions];
I --> J[Discover Enough Differences];
J -- Yes --> K[End];
J -- No --> F;


```

After correlations have run, the matches appear in the match table of the Version Tracker View as mentioned above. 

This evaluation of matches step in the workflow is the most difficult part. Making sense of the function matches, and filtering out the functions that didn't change in a meaningful way. The analyst relies heavily on the correlators to make the association, provide a score, and accept some matches.  This reduces the number of functions to review from thousands to hopefully just 10s of functions. It typically involves in some sort of cyclic match generation and potentially running of additional correlators on the remaining matches:

```mermaid

graph TD;

subgraph First Set of Correlations
A[Eval Matches] --> B[Apply Obvious Match Filter];
B --> C[Accept Matches];
end
subgraph Subsequen Correlation Run
C --> D[Eval Match Subset];
D --> E[Apply Another Correlator];
E --> F[Accept Matches];
end
F --> G[Manually inspect results];

```

Subsequent correlators can be run after *Automatic Version Tracking* to provide further clarity. Some correlators will run faster after the obvious matches are made because they no longer have to consider all of the possible functions and just run on the remaining unmatched, or conversely they can run the correlations on already accepted matches. Either way, they are able to optimize as they no longer have to deal with previously accepted matches.  

This process can be more of an art than a science. Running correlators in a different order can produce different results. User experience may vary.  The analyst can experiment by creating several different sessions using the same two binaries for comparison. 

### Review the leftovers

For the functions that could not be matched, the analyst will have to go through.  If too many unmatched, will need to add another correlator to reduce the set.

#getpicture picture of reduced set of funtions to manually match


## Getting to work

Now that we have an understanding of the tool and Ghidra is loaded up with all the of files necessary for patch diffing, we will move onto actually [performing the patch diffing](Patch%20Diffing%20Applied.md) across several sessions to see clearly what changes were introduced across the set of Windows Print Spooler CVEs.  

